import 'dart:convert';
import 'dart:typed_data';

import 'package:dart_sodium/src/shared.dart';
import 'package:ffi_helper/ffi_helper.dart';

import 'bindings/pwhash.dart' as bindings;
import 'helpers/internal_helpers.dart';

class PasswordHashException implements SodiumException {
  @override
  String toString() {
    return 'Failed to generate password hash';
  }
}

class PasswordHash {
  final bindings.PasswordHash _pwHash;

  PasswordHash({bindings.PasswordHash pwHash}) : _pwHash = pwHash ?? bindings.PasswordHash();

  bindings.OpsLimit get opsLimit => _pwHash.opslimit;

  bindings.MemLimit get memLimit => _pwHash.memlimit;

  /// Generates a password hash which can be safely stored.
  /// [opsLimit] must be between [OpsLimit.min] and [OpsLimit.max]. Defaults to [OpsLimit.interactive]
  /// [memLimit] must be between [MemLimit.min] and [MemLimit.max]. Defaults to [MemLimit.interactive]
  /// Throws a [PasswordHashException] when generating a password hash fails.
  String store(String passwordString, {int opsLimit, int memLimit}) {
    opsLimit = opsLimit ?? _pwHash.opslimit.interactive;
    memLimit = memLimit ?? _pwHash.memlimit.interactive;

    final password = Uint8List.fromList(utf8.encode(passwordString));

    checkInRange(opsLimit, _pwHash.opslimit.min, _pwHash.opslimit.max, 'Ops Limit');
    checkInRange(opsLimit, _pwHash.memlimit.min, _pwHash.memlimit.max, 'Mem Limit');
    checkInRange(opsLimit, _pwHash.passwordMin, _pwHash.passwordMax, 'Password Length');

    return free1freeZero1(
      Uint8Array.allocate(count: _pwHash.storeBytes),
      password.asArray,
      (hashPtr, passwordPtr) {
        final result = _pwHash.storage(hashPtr.rawPtr, passwordPtr.rawPtr, password.length, opsLimit, memLimit);
        if (result != 0) {
          throw PasswordHashException();
        }

        return utf8.decode(Uint8List.fromList(hashPtr.view.takeWhile((e) => e != 0).toList()));
      },
    );
  }

  /// Verifies a password with [hash] generated by [store].
  bool verify(String hashString, String passwordString) {
    final password = Uint8List.fromList(utf8.encode(passwordString));
    final hash = Uint8List.fromList(utf8.encode(hashString));

    checkInRange(hash.length, 0, _pwHash.storeBytes, 'Password Storage Length');
    checkInRange(password.length, _pwHash.passwordMin, _pwHash.passwordMax, 'Password Length');

    final hashPtr = Uint8Array.allocate(count: hash.length + 1);
    hashPtr.view.setAll(0, hash);
    hashPtr.view.last = 0;

    return free1freeZero1(hashPtr, password.asArray, (hashPtr, passwordPtr) {
      final result = _pwHash.verify(hashPtr.rawPtr, passwordPtr.rawPtr, password.length);
      return result == 0;
    });
  }

  /// Verifies if a hash generated by [store] was generated with [opsLimit] and [memLimit].
  /// If not a new hash must be generated.
  /// Throws an [ArgumentError], if the hash is invalid.
  bool needsRehash(String hashString, [int opsLimit, int memLimit]) {
    opsLimit = opsLimit ?? _pwHash.opslimit.interactive;
    memLimit = memLimit ?? _pwHash.memlimit.interactive;

    checkInRange(opsLimit, _pwHash.opslimit.min, _pwHash.opslimit.max, 'Ops Limit');
    checkInRange(opsLimit, _pwHash.memlimit.min, _pwHash.memlimit.max, 'Mem Limit');
    final hash = Uint8List.fromList(utf8.encode(hashString));
    checkInRange(hash.length, 0, _pwHash.storeBytes, 'Password Storage Length');

    final hashPtr = Uint8Array.allocate(count: hash.length + 1);
    hashPtr.view.setAll(0, hash);
    hashPtr.view.last = 0;

    return free1(hashPtr, (hashPtr) {
      final result = _pwHash.needsRehash(hashPtr.rawPtr, opsLimit, memLimit);
      return result == 0;
    });
  }
}
