import 'dart:ffi';
import 'dart:typed_data';

import 'package:ffi/ffi.dart';
import 'package:ffi_helper/ffi_helper.dart';

import 'bindings/sign.dart' as bindings;
import 'internal_helpers.dart';
import 'shared.dart';

class SignError extends Error {
  @override
  String toString() {
    return 'Failed to sign message';
  }
}

class KeyPairException implements SodiumException {
  @override
  String toString() {
    return 'Failed to initialize keypair';
  }
}

class UpdateStreamException implements SodiumException {
  @override
  String toString() {
    return 'Failed to update sign stream';
  }
}

class InvalidSignatureException implements SodiumException {
  @override
  String toString() {
    return 'The signature appears to be invalid';
  }
}

class InitStreamException implements SodiumException {
  @override
  String toString() {
    return 'Failed to initialize sign stream';
  }
}

/// Pair of public and secret key.
class KeyPair {
  final UnmodifiableUint8ListView publicKey, secretKey;

  const KeyPair._(this.publicKey, this.secretKey);

  /// Generates a pair of public and secret key.
  /// Throws [KeyPairException] when generating keys fails.
  factory KeyPair([bindings.Sign sign]) {
    final _sign = sign ?? bindings.Sign();

    final pkPtr = Uint8Array.allocate(count: _sign.publicKeyBytes);
    final skPtr = Uint8Array.allocate(count: _sign.secretKeyBytes);
    final result = _sign.keyPair(pkPtr.rawPtr, skPtr.rawPtr);
    final publicKey = UnmodifiableUint8ListView(Uint8List.fromList(pkPtr.view));
    final secretKey = UnmodifiableUint8ListView(Uint8List.fromList(skPtr.view));
    pkPtr.freeZero();
    skPtr.freeZero();
    if (result != 0) {
      throw KeyPairException();
    }
    return KeyPair._(publicKey, secretKey);
  }

  /// Derives [publicKey] and [secretKey] from [seed].
  /// Throws [KeyPairException] when generating keys fails.
  factory KeyPair.fromSeed(Uint8List seed, [bindings.Sign sign]) {
    final _sign = sign ?? bindings.Sign();

    checkExpectedLengthOf(seed.length, _sign.seedBytes, 'seed');

    return free2freeZero1(
      seed.asArray,
      Uint8Array.allocate(count: _sign.publicKeyBytes),
      Uint8Array.allocate(count: _sign.secretKeyBytes),
      (seedPtr, pkPtr, skPtr) {
        final result = _sign.seedKeyPair(pkPtr.rawPtr, skPtr.rawPtr, seedPtr.rawPtr);
        if (result != 0) {
          throw KeyPairException();
        }

        final publicKey = UnmodifiableUint8ListView(Uint8List.fromList(pkPtr.view));
        final secretKey = UnmodifiableUint8ListView(Uint8List.fromList(skPtr.view));
        return KeyPair._(publicKey, secretKey);
      },
    );
  }
}

class Sign {
  final bindings.Sign _binding;

  Sign([bindings.Sign binding]) : _binding = binding ?? bindings.Sign();

  /// Signs [message] with [secretKey]. [secretKey] must be [secretKeyBytes] long.
  Uint8List sign(Uint8List message, Uint8List secretKey) {
    checkExpectedLengthOf(secretKey.length, _binding.secretKeyBytes, 'secret key');

    return free2freeZero1(
      message.asArray,
      Uint8Array.allocate(count: message.length + _binding.signBytes),
      secretKey.asArray,
      (messagePtr, signedMessagePtr, skPtr) {
        final result = _binding.sign(signedMessagePtr.rawPtr, nullptr.cast(), messagePtr.rawPtr, message.length, skPtr.rawPtr);
        if (result != 0) {
          throw SignError();
        }
        return Uint8List.fromList(signedMessagePtr.view);
      },
    );
  }

  /// Verifies the signature of [signedMessage] generated by [sign] and extracts the message.
  /// Throws [InvalidSignatureException] when signature is invalid.
  Uint8List open(Uint8List signedMessage, Uint8List publicKey) {
    checkExpectedLengthOf(publicKey.length, _binding.publicKeyBytes, 'public key');

    return free3(
      signedMessage.asArray,
      Uint8Array.allocate(count: signedMessage.length - _binding.signBytes),
      publicKey.asArray,
      (signedMessagePtr, messagePtr, pkPtr) {
        final result = _binding.signOpen(messagePtr.rawPtr, nullptr.cast(), signedMessagePtr.rawPtr, signedMessage.length, pkPtr.rawPtr);
        if (result != 0) {
          throw InvalidSignatureException();
        }
        return Uint8List.fromList(messagePtr.view);
      },
    );
  }
}

class SignDetached {
  final bindings.Sign _binding;

  SignDetached([bindings.Sign binding]) : _binding = binding ?? bindings.Sign();

  int get signBytes => _binding.signBytes;
  int get seedBytes => _binding.seedBytes;

  Uint8List sign(Uint8List message, Uint8List secretKey) {
    checkExpectedLengthOf(secretKey.length, _binding.secretKeyBytes, 'secret key');

    return free3freeZero1(
      Uint8Array.allocate(count: _binding.signBytes),
      Uint64Array.fromPointer(allocate<Uint64>()),
      message.asArray,
      secretKey.asArray,
      (sigPtr, sigLenPtr, messagePtr, skPtr) {
        final result = _binding.signDetached(sigPtr.rawPtr, sigLenPtr.rawPtr, messagePtr.rawPtr, messagePtr.length, skPtr.rawPtr);
        if (result != 0) {
          throw SignError();
        }

        return Uint8List.fromList(sigPtr.view);
      },
    );
  }

  bool verify(Uint8List message, Uint8List signature, Uint8List publicKey) {
    checkExpectedLengthOf(publicKey.length, _binding.publicKeyBytes, 'public key');
    checkExpectedLengthOf(signature.length, _binding.signBytes, 'signature');

    return free3(
      signature.asArray,
      message.asArray,
      publicKey.asArray,
      (sigPtr, messagePtr, pkPtr) {
        final result = _binding.signVerifyDetached(sigPtr.rawPtr, messagePtr.rawPtr, messagePtr.length, pkPtr.rawPtr);
        return result == 0;
      },
    );
  }
}

Uint8List _initStream(bindings.Sign binding) {
  return freeZero1(
    Uint8Array.allocate(count: binding.stateBytes),
    (statePtr) {
      final result = binding.signInit(statePtr.rawPtr);
      if (result != 0) {
        throw InitStreamException();
      }
      return Uint8List.fromList(statePtr.view);
    },
  );
}

mixin Update {
  bindings.Sign get _binding;

  Uint8List _state;

  /// Updates stream with [message].
  /// Call [update] for every part of the message.
  /// Throws [UpdateException] when updating the state fails.
  void update(Uint8List message) {
    final statePtr = _state.asArray;
    final messagePtr = message.asArray;

    final result = _binding.signUpdate(statePtr.rawPtr, messagePtr.rawPtr, message.length);
    _state.setAll(0, statePtr.view);
    statePtr.freeZero();
    messagePtr.free();
    if (result != 0) {
      throw UpdateStreamException;
    }
  }
}

/// Generates signature for a multi-part message.
class SignStream with Update {
  @override
  final bindings.Sign _binding;

  @override
  final Uint8List _state;

  UnmodifiableUint8ListView get state => UnmodifiableUint8ListView(_state);

  /// Resume stream with a saved [state].
  SignStream.resume(this._state, {bindings.Sign binding}) : _binding = binding ?? bindings.Sign() {
    checkExpectedLengthOf(_state.length, _binding.stateBytes, 'state');
  }

  factory SignStream({bindings.Sign binding}) {
    final _binding = binding ?? bindings.Sign();
    return SignStream.resume(_initStream(_binding), binding: _binding);
  }

  /// Generates the signature for the multi-part message.
  /// The [SignStream] shouldn't be used any more after calling [finalize].
  /// [secretKey] must be [secretKeyBytes] long.
  /// Throws [SignError] when generating signature fails.
  Uint8List finalize(Uint8List secretKey) {
    return free1freeZero2(
      Uint8Array.allocate(count: _binding.signBytes),
      _state.asArray,
      secretKey.asArray,
      (signPtr, statePtr, skPtr) {
        final result = _binding.signFinal(statePtr.rawPtr, signPtr.rawPtr, nullptr.cast(), skPtr.rawPtr);
        if (result != 0) {
          throw SignError();
        }
        return Uint8List.fromList(signPtr.view);
      },
    );
  }
}

/// Stream to verify the signature of a multi-part message
class VerifyStream with Update {
  @override
  final bindings.Sign _binding;

  @override
  final Uint8List _state;

  UnmodifiableUint8ListView get state => _state;

  /// Resume stream with a saved [state].
  VerifyStream.resume(this._state, {bindings.Sign binding}) : _binding = binding ?? bindings.Sign() {
    checkExpectedLengthOf(_state.length, _binding.stateBytes, 'state');
  }

  factory VerifyStream({bindings.Sign binding}) {
    final _binding = binding ?? bindings.Sign();
    return VerifyStream.resume(_initStream(_binding), binding: _binding);
  }

  /// Verifies [signature] of a multi-part message generated by [SignStream].
  /// [publicKey] must be [publicKeyBytes] long.
  bool verify(Uint8List signature, Uint8List publicKey) {
    return free2freeZero1(
      signature.asArray,
      publicKey.asArray,
      _state.asArray,
      (signPtr, pkPtr, statePtr) {
        final result = _binding.signFinalVerify(statePtr.rawPtr, signPtr.rawPtr, pkPtr.rawPtr);
        return result == 0;
      },
    );
  }
}
